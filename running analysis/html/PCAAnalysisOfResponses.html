
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Using PCA and ICA to understand the olfactory coding space</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-09-30"><meta name="DC.source" content="PCAAnalysisOfResponses.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Using PCA and ICA to understand the olfactory coding space</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Collect responses</a></li><li><a href="#3">The z-scored responses</a></li><li><a href="#4">The covariance between neuron's responses</a></li><li><a href="#6">Eigenvalues and expained variances of each PC</a></li><li><a href="#7">The PCs of this neural space</a></li><li><a href="#8">The coding space</a></li><li><a href="#9">What does this PCA representation really means?</a></li><li><a href="#10">Any topography out there?</a></li><li><a href="#12">Which PCs are really significant? Let's shuffle it!</a></li><li><a href="#13">Using all trials instead of their average</a></li></ul></div><h2>Collect responses<a name="1"></a></h2><p>Let's use PCA to find subsets of neurons that represent odors distinctly, I will use the responses to 2,4,5-trimethylthiazole, 4,5-dimethylthiazole, isobutylacetate, isoamylacetate, exanedione and butanedione. All odors in a chemical pair smell very alike, but dimethylthiazole that smell like thiazole, however it doesn't smell a lot like TMT. Now, I will consider only the average response of each unit to an odor during the first sniff. And I will Z-score the responses of each unit.</p><pre class="codeinput">odorToUse = [8 10 11 12 13 7];

idxNeuron = 1;
<span class="keyword">for</span> idxExp = 1:length(List)
    <span class="keyword">for</span> idxShank = 1:4
        <span class="keyword">for</span> idxUnit = 1:length(exp(idxExp).shank(idxShank).cell)
            aur = [];
            responsesSpiCo = [];
            responsesTiCo = [];
            indicatore = [];
            idxOdorLoop = 1;
            <span class="keyword">for</span> idxOdor = odorToUse
                aur(idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).aurocMax(1);
                rspOn(idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).fullCycleDigitalResponsePerCycle(1);
                responsesSpiCo(:,idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).fullCycleAnalogicResponsePerCycleAllTrials(:,1);
                responsesSpiCo(:,idxOdorLoop) = responsesSpiCo(:,idxOdorLoop) - exp(idxExp).shank(idxShank).cell(idxUnit).bslSpikeRate(1);
                responsesTiCo(:,:,idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).smoothedPsth(:,4*cycleLengthDeg:5*cycleLengthDeg);
                idxOdorLoop = idxOdorLoop + 1;
            <span class="keyword">end</span>
            indicatore = find(aur&gt;=0.5);
            <span class="comment">%indicatore = find(rspOn &gt; 0);</span>
            <span class="keyword">if</span> ~isempty(indicatore) <span class="comment">%...zscore</span>

                popActivitySpCoNoZ(idxNeuron,:,:) = responsesSpiCo;
                [dim1, dim2] = size(responsesSpiCo);
                responsesSpiCo = responsesSpiCo(:); responsesSpiCo = zscore(responsesSpiCo); responsesSpiCo = reshape(responsesSpiCo, dim1, dim2);
                [dim1, dim2, dim3] = size(responsesTiCo);
                responsesTiCo = responsesTiCo(:); responsesTiCo = zscore(responsesTiCo); responsesTiCo = reshape(responsesTiCo, dim1, dim2, dim3);
                popActivitySpCo(idxNeuron,:,:) = responsesSpiCo;
                popActivityTiCo{idxNeuron} = responsesTiCo;
                cellOdorLog(idxNeuron,:) = [idxExp, idxShank, idxUnit]; <span class="comment">%keep a log</span>
                idxNeuron = idxNeuron + 1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

popActivitySpCoMean = squeeze(mean(popActivitySpCo,2));
[coeff, score, latent,~,explained] = pca(zscore(popActivitySpCoMean'));
</pre><p>All right, now I will Z-score all responses across units and then I will delete all units that don't have spikes during the stimulus window.</p><pre class="codeinput">A = popActivitySpCoMean';
[n,m] = size(A);
AMean = mean(A);
AStd = std(A);
B = (A - repmat(AMean,[n 1])) ./ repmat(AStd, [n, 1]);
Bnans = sum(B);
B(:,isnan(Bnans)) = [];
cellOdorLog(isnan(Bnans),:) = [];
</pre><h2>The z-scored responses<a name="3"></a></h2><p>And this is what the z-scored responses look like (and the experiment and shank each unit is from)</p><pre class="codeinput">odorTicks = 1:6;
odorLabels = {<span class="string">'TMT'</span>, <span class="string">'DMT'</span>, <span class="string">'IBA'</span>, <span class="string">'IAA'</span>, <span class="string">'EDN'</span>, <span class="string">'BDN'</span>};

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, <span class="string">'Position'</span>,[1,5,Xfig,Yfig]);
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
p.pack(<span class="string">'h'</span>, {10 10 80})


p(1).select ()
imagesc(cellOdorLog(:,1)); colormap(brewermap([],<span class="string">'YlOrRd'</span>)); axis <span class="string">tight</span>; title(<span class="string">'exp'</span>); freezeColors
set(gca,<span class="string">'XTick'</span>,[])
ylabel(<span class="string">'units'</span>)
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p(2).select ()
imagesc(cellOdorLog(:,2)); colormap(brewermap([],<span class="string">'YlGn'</span>)); axis <span class="string">tight</span>; title(<span class="string">'shank'</span>); freezeColors
set(gca,<span class="string">'YTick'</span>,[])
set(gca,<span class="string">'XTick'</span>,[])
p(3).select ()
imagesc(B'); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">tight</span>; title(<span class="string">'response matrix'</span>); colorbar
set(gca, <span class="string">'XTick'</span>, odorTicks);
set(gca, <span class="string">'XTickLabel'</span>, odorLabels);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
set(gca,<span class="string">'YTick'</span>,[])

p.de.margin = 1;
p.margin = [20 10 20 4];
p.select(<span class="string">'all'</span>)
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_01.png" style="width:400px;height:800px;" alt=""> <h2>The covariance between neuron's responses<a name="4"></a></h2><p>Now let's give a look at the covariance between units during the response windows</p><pre class="codeinput">covB = cov(B);

Xfig = 400;
Yfig = 400;
figure;
set(gcf, <span class="string">'Position'</span>,[1,5,Xfig,Yfig]);
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
imagesc(covB); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">square</span>; title(<span class="string">'covariance matrix'</span>); colorbar
xlabel(<span class="string">'unit #'</span>); ylabel(<span class="string">'unit #'</span>);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_02.png" style="width:400px;height:400px;" alt=""> <p>So, there are bunches of spatially close units whose reponses covary. Look at the z-scored responses. Covariances look selective for odors, which is good also because this suggests that these covariances are not a trivial result of over-clustering during spike sorting</p><h2>Eigenvalues and expained variances of each PC<a name="6"></a></h2><p>And these are its eigenvalues with their respective explained variances</p><pre class="codeinput">[PCs, D] = eig(covB);
eigenvalues = D(:);
eigenvalues = eigenvalues(eigenvalues&gt;0.1)
explained
cumulative_explaned = cumsum(explained)
</pre><pre class="codeoutput">
eigenvalues =

   23.5331
   24.7223
   29.7716
   33.1851
   37.7878


explained =

   25.3610
   22.2719
   19.9810
   16.5922
   15.7940


cumulative_explaned =

   25.3610
   47.6329
   67.6138
   84.2060
  100.0000

</pre><h2>The PCs of this neural space<a name="7"></a></h2><p>Let's give a look to each PC</p><pre class="codeinput">PCs = fliplr(PCs);
figure; set(gcf,<span class="string">'Position'</span>,[835 385 253 420]); set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
imagesc(PCs(:,1:5)); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">tight</span>; title(<span class="string">'PCs'</span>); colorbar
xlabel(<span class="string">'PCs'</span>); ylabel(<span class="string">'unit #'</span>)
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_03.png" style="width:253px;height:420px;" alt=""> <h2>The coding space<a name="8"></a></h2><p>All right, there is a lot of correlated activity during odor presentations and therefore the rank of the covariance matrix is just 5 out of ~160 unit's response vectors.In other words, the distribution of the responses lives in on a subspace that has dimensionality 5. So just to have an idea of what this sub-space looks like...</p><pre class="codeinput">Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, <span class="string">'Position'</span>,[1,5,Xfig,Yfig]);
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)

c = [102,194,165; 102,194,165;<span class="keyword">...</span>
252,141,98; 252,141,98;<span class="keyword">...</span>
141,160,203;141,160,203]/255;



p.pack(<span class="string">'v'</span>,{1/3 1/3 1/3})
p(1).select()
scatter(score(:,1), score(:,2), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC1'</span>); ylabel(<span class="string">'PC2'</span>)
h= labelpoints(score(:,1), score(:,2),odorLabels,<span class="string">'NE'</span>,0.2);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p(2).select()
scatter(score(:,2), score(:,3), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC2'</span>); ylabel(<span class="string">'PC3'</span>)
h= labelpoints(score(:,2), score(:,3),odorLabels,<span class="string">'NE'</span>,0.2);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p(3).select()
scatter(score(:,1), score(:,3), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC1'</span>); ylabel(<span class="string">'PC3'</span>)
h= labelpoints(score(:,1), score(:,3),odorLabels,<span class="string">'NE'</span>,0.2);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p.de.margin = 10;
p.margin = [5 10 5 4];
p.select(<span class="string">'all'</span>)
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_04.png" style="width:400px;height:800px;" alt=""> <h2>What does this PCA representation really means?<a name="9"></a></h2><p>Nice! Odors chemically similar are closer in the cortical amygdala coding space. But what does this really mean? Well, apparently there are subset of units that get very excited by TMT (just look at the units that contribute to the first PC and those that get excited by TMT), another subset that probably get excited by other odors and so on. Let's give a look at this interpretation. Now I will plot the projection of the response matrix on each PC.This will tell us how much a group of correlated responses are driven by each odor.</p><pre class="codeinput"><span class="keyword">for</span> i = 1:6
    proj(:,i) = PCs(:,1:4)'*B(i,:)';
<span class="keyword">end</span>

figure; set(gcf,<span class="string">'Position'</span>,[332 357 849 420]); set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
hold <span class="string">on</span>; <span class="keyword">for</span> i = 1:4
plot(proj(i,:), <span class="string">'linewidth'</span>, 4);
<span class="keyword">end</span>
legend(<span class="string">'PC1'</span>, <span class="string">'PC2'</span>, <span class="string">'PC3'</span>, <span class="string">'PC4'</span>);
hold <span class="string">off</span>; set(gca, <span class="string">'XTick'</span>, odorTicks); set(gca, <span class="string">'XTickLabel'</span>, odorLabels);
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_05.png" style="width:849px;height:420px;" alt=""> <h2>Any topography out there?<a name="10"></a></h2><p>So, it looks like there is a large bunch of units (high on PC1) that is mostly activated by TMT, suppressed by DMT and unresponsive to other odors, another bunch of units (high on PC2) that is activated by two supposedly attractive odors, exanedione and butanedione, suppressed by thiazoles and unresponsive to neutral odors and other subsets of units that cannot make their mind. Most of the covariance of responses is explained by the the first two PCs and the first 2 PCs happen to be driven respectively by units that respond to a predator odor and two units that respond to supposedly attractive odors. Units on PC1 detect TMT. Units on PC2 represent a gradient of valence. Is there any topography here? Let's see. I will resort the units of each PC according to the their shank location.</p><pre class="codeinput">sortedPCs = [PCs cellOdorLog(:,2)];
sortedPCs = sortrows(sortedPCs, size(sortedPCs,2));
sortedPCs(:,size(sortedPCs,2)) = [];
sortedShanks = sort(cellOdorLog(:,2));

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, <span class="string">'Position'</span>,[1,5,Xfig,Yfig]);
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
p.pack(<span class="string">'h'</span>, {10 80})

p(1).select()
imagesc(sortedShanks); colormap(brewermap([],<span class="string">'YlGn'</span>)); axis <span class="string">tight</span>; title(<span class="string">'shank'</span>); freezeColors
set(gca,<span class="string">'XTick'</span>,[])
ylabel(<span class="string">'units'</span>)
p(2).select()
imagesc(sortedPCs(:,1:5)); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">tight</span>; title(<span class="string">'PCs'</span>);
xlabel(<span class="string">'PCs'</span>); set(gca,<span class="string">'YTick'</span>,[])

p.de.margin = 1;
p.margin = [20 10 20 4];
p.select(<span class="string">'all'</span>)

<span class="keyword">for</span> i = 1:4
    pcShank(i,1) = sum(sortedPCs(sortedShanks==i,1));
    pcShank(i,2) = sum(sortedPCs(sortedShanks==i,2));
<span class="keyword">end</span>

figure; bar(pcShank)
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
title(<span class="string">'Topographic distribution of the first two PCs'</span>);
ylabel(<span class="string">'sum of PC coefficients'</span>); xlabel(<span class="string">'shank'</span>)
set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
</pre><img vspace="5" hspace="5" src="PCAAnalysisOfResponses_06.png" style="width:400px;height:800px;" alt=""> <img vspace="5" hspace="5" src="PCAAnalysisOfResponses_07.png" style="width:560px;height:420px;" alt=""> <p>Whoa! It looks like the first two PCs are very orthogonal in the most posterior shank</p><h2>Which PCs are really significant? Let's shuffle it!<a name="12"></a></h2><p>If we consider the covariations beyond the 3rd PC as just spurious assembly of units we could denoise the responses of each unit by zeroing the PCs beyond the 3rd one and reprojecting the responses onto this "denoising" PC space. In this way I could cleaarly see the ensemble responses in each unit.%% But How do I know which "ensembles" are real? To be more precise, which eigenvalues are significant? Well, I can shuffle odor responses for each neuron indipendently to construct a null distribution of eigenvalues where all the correlations between neurons for a given odor are destroyed. In order to increase the statistical power I will raise the number of observations by using the response in each trial (5 trials/odor, so 30-fold increase).</p><pre class="codeinput">popActivitySpCo1 = [];
dataAll = [];

<span class="keyword">for</span> idxTrial =1:n_trials
    app = [];
    app = squeeze(popActivitySpCo(:,idxTrial,:));
    app = app';
    app(:,isnan(Bnans)) = [];
    app = zscore(app);
    app = app';
    popActivitySpCo1(:,idxTrial,:) = app;
<span class="keyword">end</span>

dataAll = popActivitySpCo1;
neurons = size(dataAll,1);
trials = size(dataAll,2);
stimuli = size(dataAll,3);
dataAll = reshape(dataAll, neurons, trials .* stimuli);

covMatrix = cov(dataAll');
covMatrix(isnan(covMatrix))=0;
[eigenvectors,d] = eig(covMatrix);
eigenvaluesTrue=diag(d);
number_of_permutations = 1000;
permutations_percentile = 90;
control_max_eig=zeros(1,number_of_permutations);
<span class="keyword">for</span> surr_idx = 1:number_of_permutations
    controlResponses=zeros(size(dataAll));
    <span class="keyword">for</span> neuron_idx = 1:size(dataAll,1)
        controlResponses(neuron_idx,:) = dataAll(neuron_idx,randperm(size(dataAll,2)));
    <span class="keyword">end</span>
    covarianceMatrix = cov(controlResponses');
    covarianceMatrix(isnan(covarianceMatrix))=0;
    [garbage,eigenvalues]=eig(covarianceMatrix);
    control_max_eig(surr_idx)=max(reshape(eigenvalues,1,[]));
<span class="keyword">end</span>

lambda_max = prctile(control_max_eig, permutations_percentile);
NumberOfSignificantEigenvalues = sum(eigenvaluesTrue&gt;lambda_max)

[garbage,PC_position] = sort(-eigenvaluesTrue);
AssemblyTemplates = eigenvectors(:,PC_position(1:NumberOfSignificantEigenvalues));
</pre><pre class="codeoutput">
NumberOfSignificantEigenvalues =

     2

</pre><h2>Using all trials instead of their average<a name="13"></a></h2><p>Ah! The first 2 eigenvalues are significant. So it looks like there 2 are ensembles here. One for TMT and the other one for the 'like-dislike' gradient. Let's give a look at the PC space now that we used all trials and not just their average</p><pre class="codeinput">[coeff, score, latent,~,explained] = pca(dataAll);

figure; set(gcf,<span class="string">'Position'</span>,[831 378 444 420]); set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>);
imagesc(dataAll); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">tight</span>; title(<span class="string">'response matrix'</span>); colorbar
xlabel(<span class="string">'every 5 trials is a new odor (TMT, DMT, IBA, IAA, EDN, BDN'</span>)


figure; set(gcf,<span class="string">'Position'</span>,[835 385 253 420]); set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
imagesc(coeff(:,1:3)); colormap(brewermap([],<span class="string">'*RdBu'</span>)); axis <span class="string">tight</span>; title(<span class="string">'PCs'</span>); colorbar
xlabel(<span class="string">'PCs'</span>); ylabel(<span class="string">'unit #'</span>)

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, <span class="string">'Position'</span>,[1,5,Xfig,Yfig]);
set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)

c = [102,194,165; 102,194,165; 102,194,165; 102,194,165; 102,194,165;<span class="keyword">...</span>
    102,194,165;102,194,165;102,194,165;102,194,165;102,194,165;<span class="keyword">...</span>
    252,141,98; 252,141,98;252,141,98;252,141,98;252,141,98;<span class="keyword">...</span>
    252,141,98; 252,141,98;252,141,98;252,141,98;252,141,98;<span class="keyword">...</span>
    141,160,203; 141,160,203; 141,160,203; 141,160,203; 141,160,203;<span class="keyword">...</span>
    141,160,203;141,160,203;141,160,203;141,160,203;141,160,203;]/255;



p.pack(<span class="string">'v'</span>,{1/3 1/3 1/3})
p(1).select()
scatter(score(:,1), score(:,2), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC1'</span>); ylabel(<span class="string">'PC2'</span>)

set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p(2).select()
scatter(score(:,2), score(:,3), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC2'</span>); ylabel(<span class="string">'PC3'</span>)

set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p(3).select()
scatter(score(:,1), score(:,3), 50, c, <span class="string">'filled'</span>); xlim([-12 12]); ylim([-12 12]); axis <span class="string">square</span>
xlabel(<span class="string">'PC1'</span>); ylabel(<span class="string">'PC3'</span>)

set(gca,<span class="string">'FontName'</span>,<span class="string">'Arial'</span>,<span class="string">'Fontsize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'Box'</span>,<span class="string">'off'</span>);
p.de.margin = 10;
p.margin = [5 10 5 4];
p.select(<span class="string">'all'</span>)

<span class="comment">% Well, trials with similar odors stay together</span>
proj = [];
<span class="keyword">for</span> i = 1:6
    proj(:,i) = PCs(:,1:4)'*B(i,:)';
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:size(dataAll,2)
    proj(:,i) = AssemblyTemplates(:,1:2)'*dataAll(:,i);
<span class="keyword">end</span>

figure; set(gcf,<span class="string">'Position'</span>,[332 357 849 420]); set(gcf,<span class="string">'Color'</span>,<span class="string">'w'</span>)
hold <span class="string">on</span>; <span class="keyword">for</span> i = 1:2
plot(proj(i,:), <span class="string">'linewidth'</span>, 4);
<span class="keyword">end</span>
legend(<span class="string">'PC1'</span>, <span class="string">'PC2'</span>);
hold <span class="string">off</span>;

k = 1;
<span class="keyword">for</span> i = 1:5:25
    x(k) = sum(proj(1,i:i+4))/5;
    y(k) = sum(proj(2,i:i+4))/5;
    k = k+1;
<span class="keyword">end</span>
figure; plot(x)
hold <span class="string">on</span>
plot(y)



zDataAll = dataAll';

time_projection=zeros(size(AssemblyTemplates,2),size(zDataAll,1));
<span class="keyword">for</span> assembly_idx = 1:size(AssemblyTemplates,2)

    <span class="comment">% computing projector</span>
    ASSEMBLYPROJECTOR=AssemblyTemplates(:,assembly_idx)*AssemblyTemplates(:,assembly_idx)';
    ASSEMBLYPROJECTOR=squeeze(ASSEMBLYPROJECTOR)-diag(diag(squeeze(ASSEMBLYPROJECTOR)));


    <span class="keyword">for</span> ntime=1:size(zDataAll,1)

        time_projection(assembly_idx,ntime)=(zDataAll(:,ntime)'*ASSEMBLYPROJECTOR*zDataAll(:,ntime));

    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput error">Error using scatter (line 81)
CData must be an RGB triplet, an M-by-1 vector of the same length as X, or an M-by-3 matrix.

Error in PCAAnalysisOfResponses (line 319)
scatter(score(:,1), score(:,2), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Using PCA and ICA to understand the olfactory coding space


%% Collect responses 
% Let's use PCA to find subsets of neurons that represent odors distinctly,
% I will use the responses to 2,4,5-trimethylthiazole, 4,5-dimethylthiazole,
% isobutylacetate, isoamylacetate, exanedione and butanedione. All odors in a chemical pair smell very alike, but dimethylthiazole that smell like thiazole, however
% it doesn't smell a lot like TMT.
% Now, I will consider only the average response of each unit to an odor during the first sniff. And I will Z-score the responses of each unit.

odorToUse = [8 10 11 12 13 7];

idxNeuron = 1;
for idxExp = 1:length(List)
    for idxShank = 1:4
        for idxUnit = 1:length(exp(idxExp).shank(idxShank).cell)
            aur = [];
            responsesSpiCo = [];
            responsesTiCo = [];
            indicatore = [];
            idxOdorLoop = 1;
            for idxOdor = odorToUse
                aur(idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).aurocMax(1);
                rspOn(idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).fullCycleDigitalResponsePerCycle(1);
                responsesSpiCo(:,idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).fullCycleAnalogicResponsePerCycleAllTrials(:,1);
                responsesSpiCo(:,idxOdorLoop) = responsesSpiCo(:,idxOdorLoop) - exp(idxExp).shank(idxShank).cell(idxUnit).bslSpikeRate(1);
                responsesTiCo(:,:,idxOdorLoop) = exp(idxExp).shank(idxShank).cell(idxUnit).odor(idxOdor).smoothedPsth(:,4*cycleLengthDeg:5*cycleLengthDeg);
                idxOdorLoop = idxOdorLoop + 1;
            end
            indicatore = find(aur>=0.5);
            %indicatore = find(rspOn > 0);
            if ~isempty(indicatore) %...zscore
                
                popActivitySpCoNoZ(idxNeuron,:,:) = responsesSpiCo;
                [dim1, dim2] = size(responsesSpiCo);
                responsesSpiCo = responsesSpiCo(:); responsesSpiCo = zscore(responsesSpiCo); responsesSpiCo = reshape(responsesSpiCo, dim1, dim2);
                [dim1, dim2, dim3] = size(responsesTiCo);
                responsesTiCo = responsesTiCo(:); responsesTiCo = zscore(responsesTiCo); responsesTiCo = reshape(responsesTiCo, dim1, dim2, dim3);
                popActivitySpCo(idxNeuron,:,:) = responsesSpiCo;
                popActivityTiCo{idxNeuron} = responsesTiCo;
                cellOdorLog(idxNeuron,:) = [idxExp, idxShank, idxUnit]; %keep a log 
                idxNeuron = idxNeuron + 1;
            end
        end
    end
end

popActivitySpCoMean = squeeze(mean(popActivitySpCo,2));
[coeff, score, latent,~,explained] = pca(zscore(popActivitySpCoMean'));
%% 
% All right, now I will Z-score all responses across units and then I will delete all units that don't have spikes during the stimulus window.
A = popActivitySpCoMean';
[n,m] = size(A);
AMean = mean(A);
AStd = std(A);
B = (A - repmat(AMean,[n 1])) ./ repmat(AStd, [n, 1]);
Bnans = sum(B);
B(:,isnan(Bnans)) = [];
cellOdorLog(isnan(Bnans),:) = [];
%% The z-scored responses
% And this is what the z-scored responses look like (and the experiment and shank each unit is from)
odorTicks = 1:6;
odorLabels = {'TMT', 'DMT', 'IBA', 'IAA', 'EDN', 'BDN'};

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, 'Position',[1,5,Xfig,Yfig]);
set(gcf,'Color','w')
p.pack('h', {10 10 80})


p(1).select ()
imagesc(cellOdorLog(:,1)); colormap(brewermap([],'YlOrRd')); axis tight; title('exp'); freezeColors
set(gca,'XTick',[])
ylabel('units')
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p(2).select ()
imagesc(cellOdorLog(:,2)); colormap(brewermap([],'YlGn')); axis tight; title('shank'); freezeColors
set(gca,'YTick',[])
set(gca,'XTick',[])
p(3).select ()
imagesc(B'); colormap(brewermap([],'*RdBu')); axis tight; title('response matrix'); colorbar
set(gca, 'XTick', odorTicks);
set(gca, 'XTickLabel', odorLabels);
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
set(gca,'YTick',[])

p.de.margin = 1;
p.margin = [20 10 20 4];
p.select('all')







%% The covariance between neuron's responses 
% Now let's give a look at the covariance between units during the response windows
covB = cov(B);

Xfig = 400;
Yfig = 400;
figure;
set(gcf, 'Position',[1,5,Xfig,Yfig]);
set(gcf,'Color','w')
imagesc(covB); colormap(brewermap([],'*RdBu')); axis square; title('covariance matrix'); colorbar
xlabel('unit #'); ylabel('unit #');
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');


%%
% So, there are bunches of spatially close units whose reponses covary.
% Look at the z-scored responses. Covariances look selective for odors, which is good also because this suggests that these covariances are not a trivial
% result of over-clustering during spike sorting

%% Eigenvalues and expained variances of each PC
% And these are its eigenvalues with their respective explained variances 
[PCs, D] = eig(covB);
eigenvalues = D(:);
eigenvalues = eigenvalues(eigenvalues>0.1)
explained
cumulative_explaned = cumsum(explained)

%% The PCs of this neural space
% Let's give a look to each PC
PCs = fliplr(PCs);
figure; set(gcf,'Position',[835 385 253 420]); set(gcf,'Color','w')
imagesc(PCs(:,1:5)); colormap(brewermap([],'*RdBu')); axis tight; title('PCs'); colorbar
xlabel('PCs'); ylabel('unit #')
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');

%% The coding space
% All right, there is a lot of correlated activity during odor presentations and therefore the rank of the covariance matrix is just 5 out of 
% ~160 unit's response vectors.In other words, the distribution of the responses lives in on a subspace that has dimensionality 5.
% So just to have an idea of what this sub-space looks like...
Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, 'Position',[1,5,Xfig,Yfig]);
set(gcf,'Color','w')

c = [102,194,165; 102,194,165;...
252,141,98; 252,141,98;...
141,160,203;141,160,203]/255;



p.pack('v',{1/3 1/3 1/3})
p(1).select()
scatter(score(:,1), score(:,2), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC1'); ylabel('PC2')
h= labelpoints(score(:,1), score(:,2),odorLabels,'NE',0.2); 
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p(2).select()
scatter(score(:,2), score(:,3), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC2'); ylabel('PC3')
h= labelpoints(score(:,2), score(:,3),odorLabels,'NE',0.2); 
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p(3).select()
scatter(score(:,1), score(:,3), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC1'); ylabel('PC3')
h= labelpoints(score(:,1), score(:,3),odorLabels,'NE',0.2); 
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p.de.margin = 10;
p.margin = [5 10 5 4];
p.select('all')


%% What does this PCA representation really means?
% Nice! Odors chemically similar are closer in the cortical amygdala coding space.
% But what does this really mean?
% Well, apparently there are subset of units that get very excited by TMT (just look at the units that contribute to the first PC and those that get excited by TMT),
% another subset that probably get excited by other odors and so on. Let's give a look at this interpretation. Now I will plot the projection of the response matrix
% on each PC.This will tell us how much a group of correlated responses are driven by each odor.
for i = 1:6
    proj(:,i) = PCs(:,1:4)'*B(i,:)';
end

figure; set(gcf,'Position',[332 357 849 420]); set(gcf,'Color','w')
hold on; for i = 1:4
plot(proj(i,:), 'linewidth', 4);
end
legend('PC1', 'PC2', 'PC3', 'PC4');
hold off; set(gca, 'XTick', odorTicks); set(gca, 'XTickLabel', odorLabels);
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');


%% Any topography out there? 
% So, it looks like there is a large bunch of units (high on PC1) that is mostly activated by TMT, suppressed by DMT and unresponsive to other odors, 
% another bunch of units (high on PC2) that is activated by two supposedly attractive odors, exanedione and butanedione, suppressed by thiazoles and
% unresponsive to neutral odors and other subsets of units that cannot make their mind. Most of the covariance of responses is explained 
% by the the first two PCs and the first 2 PCs happen to be driven respectively by units that respond to a predator odor and two units that respond
% to supposedly attractive odors.
% Units on PC1 detect TMT. Units on PC2 represent a gradient of valence.
% Is there any topography here? Let's see. I will resort the units of each PC according to the their shank location. 
sortedPCs = [PCs cellOdorLog(:,2)];
sortedPCs = sortrows(sortedPCs, size(sortedPCs,2));
sortedPCs(:,size(sortedPCs,2)) = [];
sortedShanks = sort(cellOdorLog(:,2));

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, 'Position',[1,5,Xfig,Yfig]);
set(gcf,'Color','w')
p.pack('h', {10 80})

p(1).select()
imagesc(sortedShanks); colormap(brewermap([],'YlGn')); axis tight; title('shank'); freezeColors
set(gca,'XTick',[])
ylabel('units')
p(2).select()
imagesc(sortedPCs(:,1:5)); colormap(brewermap([],'*RdBu')); axis tight; title('PCs'); 
xlabel('PCs'); set(gca,'YTick',[])

p.de.margin = 1;
p.margin = [20 10 20 4];
p.select('all')

for i = 1:4
    pcShank(i,1) = sum(sortedPCs(sortedShanks==i,1));
    pcShank(i,2) = sum(sortedPCs(sortedShanks==i,2));
end

figure; bar(pcShank)
set(gcf,'Color','w')
title('Topographic distribution of the first two PCs');
ylabel('sum of PC coefficients'); xlabel('shank')
set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
%%
% Whoa! It looks like the first two PCs are very orthogonal in the most
% posterior shank
%% Which PCs are really significant? Let's shuffle it!
% If we consider the covariations beyond the 3rd PC as just spurious assembly of units we could denoise the responses of each unit by zeroing the PCs beyond the
% 3rd one and reprojecting the responses onto this "denoising" PC space. In this way I could cleaarly see the ensemble responses in each unit.%% But How do I know which "ensembles" are real? To be more precise, which eigenvalues are significant? Well, I can shuffle odor responses for each neuron
% indipendently to construct a null distribution of eigenvalues where all the correlations between neurons for a given odor are destroyed.
% In order to increase the statistical power I will raise the number of observations by using the response in each trial (5 trials/odor, so 30-fold increase).
popActivitySpCo1 = [];
dataAll = [];

for idxTrial =1:n_trials
    app = [];
    app = squeeze(popActivitySpCo(:,idxTrial,:));
    app = app';
    app(:,isnan(Bnans)) = [];
    app = zscore(app);
    app = app';
    popActivitySpCo1(:,idxTrial,:) = app;
end

dataAll = popActivitySpCo1;
neurons = size(dataAll,1);
trials = size(dataAll,2);
stimuli = size(dataAll,3);
dataAll = reshape(dataAll, neurons, trials .* stimuli);

covMatrix = cov(dataAll'); 
covMatrix(isnan(covMatrix))=0; 
[eigenvectors,d] = eig(covMatrix);
eigenvaluesTrue=diag(d);
number_of_permutations = 1000;
permutations_percentile = 90;
control_max_eig=zeros(1,number_of_permutations);
for surr_idx = 1:number_of_permutations
    controlResponses=zeros(size(dataAll));
    for neuron_idx = 1:size(dataAll,1)
        controlResponses(neuron_idx,:) = dataAll(neuron_idx,randperm(size(dataAll,2)));
    end
    covarianceMatrix = cov(controlResponses');
    covarianceMatrix(isnan(covarianceMatrix))=0;
    [garbage,eigenvalues]=eig(covarianceMatrix);
    control_max_eig(surr_idx)=max(reshape(eigenvalues,1,[]));
end

lambda_max = prctile(control_max_eig, permutations_percentile);
NumberOfSignificantEigenvalues = sum(eigenvaluesTrue>lambda_max)

[garbage,PC_position] = sort(-eigenvaluesTrue);
AssemblyTemplates = eigenvectors(:,PC_position(1:NumberOfSignificantEigenvalues));

%% Using all trials instead of their average
% Ah! The first 2 eigenvalues are significant. So it looks like there 2 are ensembles here. One for TMT and the other one for the 'like-dislike' gradient.
% Let's give a look at the PC space now that we used all trials and not just their average

[coeff, score, latent,~,explained] = pca(dataAll);

figure; set(gcf,'Position',[831 378 444 420]); set(gcf,'Color','w');
imagesc(dataAll); colormap(brewermap([],'*RdBu')); axis tight; title('response matrix'); colorbar
xlabel('every 5 trials is a new odor (TMT, DMT, IBA, IAA, EDN, BDN')


figure; set(gcf,'Position',[835 385 253 420]); set(gcf,'Color','w')
imagesc(coeff(:,1:3)); colormap(brewermap([],'*RdBu')); axis tight; title('PCs'); colorbar
xlabel('PCs'); ylabel('unit #')

Xfig = 400;
Yfig = 900;
figure;
p = panel();
set(gcf, 'Position',[1,5,Xfig,Yfig]);
set(gcf,'Color','w')

c = [102,194,165; 102,194,165; 102,194,165; 102,194,165; 102,194,165;...
    102,194,165;102,194,165;102,194,165;102,194,165;102,194,165;...
    252,141,98; 252,141,98;252,141,98;252,141,98;252,141,98;...
    252,141,98; 252,141,98;252,141,98;252,141,98;252,141,98;...
    141,160,203; 141,160,203; 141,160,203; 141,160,203; 141,160,203;...
    141,160,203;141,160,203;141,160,203;141,160,203;141,160,203;]/255;



p.pack('v',{1/3 1/3 1/3})
p(1).select()
scatter(score(:,1), score(:,2), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC1'); ylabel('PC2')

set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p(2).select()
scatter(score(:,2), score(:,3), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC2'); ylabel('PC3')

set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p(3).select()
scatter(score(:,1), score(:,3), 50, c, 'filled'); xlim([-12 12]); ylim([-12 12]); axis square
xlabel('PC1'); ylabel('PC3')

set(gca,'FontName','Arial','Fontsize',14,'FontWeight','normal','TickDir','out','Box','off');
p.de.margin = 10;
p.margin = [5 10 5 4];
p.select('all')

% Well, trials with similar odors stay together
proj = [];
for i = 1:6
    proj(:,i) = PCs(:,1:4)'*B(i,:)';
end
for i = 1:size(dataAll,2)
    proj(:,i) = AssemblyTemplates(:,1:2)'*dataAll(:,i);
end

figure; set(gcf,'Position',[332 357 849 420]); set(gcf,'Color','w')
hold on; for i = 1:2
plot(proj(i,:), 'linewidth', 4);
end
legend('PC1', 'PC2');
hold off; 

k = 1;
for i = 1:5:25
    x(k) = sum(proj(1,i:i+4))/5;
    y(k) = sum(proj(2,i:i+4))/5;
    k = k+1;
end
figure; plot(x)
hold on
plot(y)



zDataAll = dataAll';

time_projection=zeros(size(AssemblyTemplates,2),size(zDataAll,1));
for assembly_idx = 1:size(AssemblyTemplates,2)
    
    % computing projector
    ASSEMBLYPROJECTOR=AssemblyTemplates(:,assembly_idx)*AssemblyTemplates(:,assembly_idx)';
    ASSEMBLYPROJECTOR=squeeze(ASSEMBLYPROJECTOR)-diag(diag(squeeze(ASSEMBLYPROJECTOR)));
    

    for ntime=1:size(zDataAll,1)
        
        time_projection(assembly_idx,ntime)=(zDataAll(:,ntime)'*ASSEMBLYPROJECTOR*zDataAll(:,ntime));
        
    end
    
end




##### SOURCE END #####
--></body></html>